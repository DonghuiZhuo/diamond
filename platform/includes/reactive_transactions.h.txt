#ifndef REACTIVE_TRANSACTIONS_H
#define REACTIVE_TRANSACTIONS_H

typedef uint64_t rtxn_id;
typedef struct rtxn_info {
    rtxn_id id;
    timestamp ts;
}

map<rtxn_id, txn_function_t> funcMap;
map<rtxn_id, std::map<std::string> > readsetMap;

rtxn_info getNextPendingRtxn();
void registerRtxn(rtxn_id id, timestamp ts, readset set);
void updateReadSet(rtxn_id id, timestamp ts, readset set);

// Things we need(but that might not necessarily go here)
readset = DObject::ReactiveCommit();

/*
 * This is the code that will go in each binding's TransactionManager
 */

reactive_txn(func) {
    DObject::TransactionBegin(global_ts); // run transaction at time global_ts
    func()
    readset = DObject::ReactiveCommit();
    if (!funcMap.containsValue(func)) {
        rtxn_id id = getNewId();
        funcMap.set(id, func);
        readsetMap.set(id, std::set<std::string>());

        registerRtxn(id, global_ts, set);
    }
    //else, call updateReadSet() with the read set
}

// main reactive loop
while(true) {
    rtxn_info info = getNextPendingRtxn();
    rtxn_id id = info.id;
    timestamp ts = info.ts;
    txn_function_t func = funcMap.get(id);
    DObject::TransactionBegin(ts); // run transaction at time ts
    func();
    readset = DObject::ReactiveCommit();
    oldReadset = readsetMap.get(id);
    if (readset != oldReadset) {
        updateReadSet(id, ts, readset);
    }
}

#endif
